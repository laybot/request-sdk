问题复盘
========
1. Webman 项目在一次 `composer update` 后开始持续 401。
2. 日志里出现
   ```
   ParseError: Unterminated comment starting line 402
   /vendor/firebase/php-jwt/src/JWT.php:402
   ```  
   说明 **PHP 解析 jwt 库源码本身时就挂掉**，业务代码根本没执行到校验逻辑。
3. 对比两套代码发现 **apiServer** 的  
   `vendor/firebase/php-jwt/src/JWT.php` 文件被截断──402 行出现了 `/*` 却没有 `*/`。
4. 删除 `vendor/firebase/php-jwt` 并 `composer require firebase/php-jwt:6.11.1` 后一切恢复。

根因
----
• 依赖包在上一次下载 / 解压过程中出现“脏写”或被意外修改，导致源码语法不完整。  
常见触发点：
- 服务器断电 / OOM / 进程被 kill
- 磁盘坏块或 I/O 报错
- 手工在 `vendor` 里搜索替换 / debug
- 合并工具把冲突标记写进来了

缺陷之所以“难发现”
-------------------
1. **ParseError** 在进程启动后第一次加载类文件才抛，而 Webman 不会把 stack 全量输出到浏览器，只在日志里留一条异常；表面看就是“JWT 验证失败”。
2. 因为另一份（ThinkPHP 项目）正常，更容易把注意力放到“跨框架 / 版本差异”上。
3. 大家默认“不改 vendor 目录”，很少会怀疑**第三方源码**本身坏了。

快速定位技巧
------------
1. 看到 `ParseError` 而不是逻辑异常，第一反应应是 **php -l**（lint）有文件语法错误。
   ```bash
   php -l vendor/firebase/php-jwt/src/JWT.php
   ```
2. 若怀疑整包损坏，可一次性 lint 全部依赖：
   ```bash
   find vendor -name "*.php" -print0 | xargs -0 -n1 php -l > /tmp/lint.log
   ```
3. PHP 8.1+ 可启用 `opcache.file_cache_only` 并通过 `opcache_compile_file` 预编译，编译阶段即可发现 ParseError。

上线/部署最佳实践
-----------------
1. 生产环境**绝不**直接 `composer update`，而是：
   ```
   composer install --no-dev --prefer-dist --no-interaction
   ```
   始终以版本锁定的 `composer.lock` 为准。
2. 把 `vendor` 排除在任何 VCS commit、IDE 全局替换之外；如需调试借助 IDE「Mark as Read-only」。
3. CI/CD 在打包后对 `vendor` 目录做一次 `php -l` 或者 `composer validate --strict`。
4. 如果服务器电源/硬盘不稳定，定期：
    - 查看 `dmesg | grep -i error`
    - 跑 `smartctl -a /dev/sdX`
    - 执行文件系统自检 `fsck`。
5. 使用 **composer 2.2+** 可在 `config` 中打开 `"verify-peer": true, "installers-skip": []`，并利用包自带的 `sha256` 校验（dist 方式自动校验）。
6. 部署完重启 PHP-FPM 或 Webman，立即访问一个接口进行“烟测”；若 ParseError 存在，能第一时间暴露。
7. 若想彻底避免「意外修改 vendor」，可以：
    - 将 vendor 打包成“资产”，部署时直接解压；
    - 或者在 Docker 镜像里，把 `vendor` 层放到 RUN `composer install` 之后的独立 layer；线上容器根本拿不到写权限。

应急排障流程（可做成 SOP）
--------------------------
1. 收到 401 等异常 → 先看 **日志类型**，若是 Parse/SyntaxError → 立即 `php -l` 目标文件。
2. 若文件损坏 → `rm -rf vendor/包名 && composer install` 重装；  
   · 记得 `composer clear-cache` 防止本地 cache 继续把错包拷回。
3. 若硬盘疑似损坏 → 查看 SMART / dmesg，必要时迁移数据。
4. 恢复后立刻加“包完整性检测”到 CI，使同类问题可提前 100 % 捕捉。

结论
----
这次“JWT 验证全挂”并非代码或依赖版本不兼容，而是 **依赖文件被写坏**。  
重装依赖即可恢复，但更重要的是把「防坏 & 快速检测」纳入日常流程，避免生产再次踩坑。